타입과 함수의 범주는 프로그래밍에서 매우 중요한 역할을 맡는다. 따라서 이 목차에서는 타입이 무엇이고 왜 필요한지를 다룰 것이다.

# 타입을 누가 필요로 하는가?
정적 대 동적 타이핑, 강 타입 대 약 타입에 대한 논쟁은 일부 논란의 여지가 있다. 이 선택들을 사고 실험으로 설명해보겠다.

![](image-1.png)
컴퓨터 키보드에서 무작위로 키를 누르며 행복하게 프로그램을 생성, 컴파일, 실행하는 수백만 마리의 원숭이를 상상해 보자. 기계어로는 원숭이가 생성한 어떤 바이트 조합이든 모두 받아들여져 실행된다. 하지만 고급 언어에서는 컴파일러가 어휘적이고 문법적인 오류를 방지하며, 우리는 이를 높이 평가한다. 그럼으로 인해서 많은 원숭이들이 바나나를 받지 못할 것이지만, 남은 프로그램들은 유용할 가능성이 더 높아진다. 

타입 검사는 무의미한 프로그램에 대한 또 다른 장벽을 제공한다. 또한, 동적 타입 언어에서는 타입 불일치가 런타임에 발견되는 반면, 강타입 정적 검사 언어에서는 타입 불일치가 컴파일 시간에 발견되어 실행될 기회가 있기 전에 많은 잘못된 프로그램을 제거한다. 

그렇다면 우리의 목표는 원숭이를 행복하게 하는 것인가, 아니면 올바른 프로그램을 생산하는 것인가?

실제로 프로그래밍을 할때 바나나 받기와 같은 간단한 프로그램을 만드는 경우는 잘 없다. 셰익스피어의 전체 작품을 목표로 한다고 생각해보자. 이런 경우 맞춤법 검사기와 문법 검사기를 루프에 포함시키면 목표를 얻을 확률이 크게 증가할 것이다. 타입 검사기는 로미오가 한 번 인간으로 선언되다면, 그가 잎을 틔우거나 강력한 중력장에서 광자를 가두는 일이 없도록 할 것이다.

# 타입은 합성 가능성에 관한 것
범주론은 화살표들을 합성하는 것에 관한 이론이다. 하지만 아무 두 화살표나 합성될 수 있는 것은 아니다. 한 화살표의 목표 대상은 다음 화살표의 출발 대상과 같아야 한다. 프로그래밍에서는 한 함수의 결과를 다른 함수로 전달한다. 소스 함수가 생성한 데이터를 대상 함수가 올바르게 해석할 수 없다면 프로그램은 작동하지 않는다. 두 끝이 맞아떨어져야 구성이 합성한다. 언어의 타입 시스템이 강할수록 이러한 일치를 더 잘 설명하고 기계적으로 검증할 수 있다.

강력한 정적 타입 검사에 대해 제기되는 반론은 그것이 의미상 올바른 프로그램더라도 컴파일에서 제외시킬 수 있다는 주장이다. 실제로, 이러한 경우는 극히 드물게 발생하며, 모든 언어는 정말 필요할 때는 타입 시스템을 우회할 수 있는 백도어를 제공한다. 러스트에서는 unsafe블록, 트레이트 객체, Any 트레이트 등이 있다. 심지어 Haskell에도 unsafeCoerce가 있다. 하지만 이러한 장치는 신중하게 사용되어야 한다. 프란츠 카프카의 등장인물, 그레고르 잠자가 거대한 벌레로 변신할 때 타입 시스템을 깨뜨렸고, 우리 모두 그 결말을 알고 있다.

또 다른 반론은 타입을 다루는 것이 프로그래머에게 너무 많은 부담을 준다는 것이다. C++에서 몇 가지 이터레이터 선언을 직접 작성해야 했던 경험 후, 이 감정에 동감할 수 있었다. 하지만, 타입 추론이라는 기술을 통해서 컴파일러를 통해 대부분의 타입이 추론될 수 있다. C++에서는 이제 변수를 auto로 선언하고 컴파일러가 그 타입을 파악하게 할 수 있다. 러스트에서는 타입 명시가 기본적으로 선택이다. 변수를 정의할때나 반환 타입, 클로저 등에서까지 타입 추론을 적용해 코드의 간결성을 높이면서도 타입 안전성을 유지할 수 있다.

Haskell에서는 몇몇 경우를 제외하고, 러스트와 마찬가지로 타입 어노테이션은 전적으로 선택적이다. 그럼에도 불구하고 프로그래머들은 타입을 명시하는 경향이 있는데, 이는 코드의 의미론에 대해 많은 것을 알려주고, 컴파일 오류를 이해하기 쉽게 만들기 때문이다. Haskell에서는 프로젝트를 시작할 때 타입을 명시하는 것이 일반적인 관행이다. 이는 나중에 구현을 이끌고 컴파일러가 강제하는 주석이 된다.

강력한 정적 타이핑은 종종 코드를 테스트하지 않는 핑계로 사용된다. 때때로 Haskell 프로그래머들이 "컴파일되면, 그것은 정확해야 한다."라고 말하는 것을 들을 수 있다. 물론, 타입이 정확한 프로그램이 올바른 출력을 생성한다는 보장은 없다. 이런 태도의 결과로, 여러 연구에서 Haskell은 예상만큼 코드 품질에서 앞서 나가지 못했다. 상업적 환경에서는 소프트웨어 개발의 경제성과 최종 사용자의 관용도와 모든 것이 관련되어 있어, 버그 수정의 압박이 특정 품질 수준까지만 적용된다는 것이 밝혀졌다. 이는 프로그래밍 언어나 방법론과는 거의 상관이 없다. 프로젝트가 일정에 뒤처지거나 기능성이 크게 떨어드는 경우의 수를 측정하는 것이 평가에 더 좋다.

단위 테스트가 강타입 시스템을 대체할 수 있다는 주장에 대하여, 강타입 언어에서 자주 사용되는 리팩토링 방법, 즉 특정 함수의 인자 타입을 변경하는 경우를 생각해 보자. 강타입 언어에서는 해당 함수의 선언부를 수정하고 발생하는 모든 컴파일 오류를 해결하기만 하면 된다. 반면, 약타입 언어에서는 함수가 이제 다른 종류의 데이터를 요구한다는 정보가 자동으로 호출 부분까지 전달되지 않는다. 단위 테스트가 일부 불일치를 발견할 수는 있지만, 테스트는 대부분의 경우 확실성보다는 확률에 기반을 둔 과정이다. 따라서, 테스팅은 증명의 대안으로는 믿음직하지 않다. 테스팅은 증명의 빈약한 대체물일 뿐이다.

# 타입이 무엇인가?
타입을 이해하는 가장 단순한 방법은 그것들이 값의 집합이라고 보는 것이다. 

Haskell에서 Bool 타입(구체적인 타입은 대문자로 시작한다는 점을 기억하라)은 True와 False, 두 원소로 구성된 집합이다. Char 타입은 a나 ą 같은 모든 유니코드 문자를 포함하는 집합이다.

집합은 유한할 수도 있고 무한할 수도 있다. Char의 리스트인 String 타입은 무한 집합의 예시이다.

x를 Integer로 선언할 때,
```haskell
x :: Integer
```
이것은 x가 정수 집합의 한 원소라고 말하는 것이다. Haskell에서 Integer는 무한 집합이며, 임의 정밀도 산수에 사용된다. C++의 int와 같은 기계 타입에 해당하는 유한 집합인 Int도 존재한다.

사실 타입과 집합을 동일시하기에는 몇 가지 미묘한 점이 있다. 순환 정의를 포함하는 다형성 함수 문제와 모든 집합의 집합을 가질 수 없다는 문제가 있지만, 약속대로 나는 수학적 엄밀함에 집착하지 않을 것이다. 

중요한 것은 Set이라고 불리는 집합의 범주가 있다는 것이며, 우리는 그것을 사용할 것이다.   
Set에서 대상은 집합이며, 사상(화살표)은 함수이다.

Set은 우리가 실제로 그 대상 내부를 들여다볼 수 있어 많은 직관을 얻을 수 있는 매우 특별한 범주이다. 예를 들어, 우리는 빈 집합에 원소가 없다는 것, 특별한 한 원소 집합이 존재한다는 것, 함수가 한 집합의 원소를 다른 집합의 원소로 매핑한다는 것을 알고 있다. 함수는 두 원소를 하나로 매핑할 수는 있지만 한 원소를 두 개로 매핑할 수는 없다. 항등 함수는 집합의 각 원소를 그 자체로 매핑한다는 사실 등을 우리는 알고 있다. 우리의 계획은 이 모든 정보를 점차 잊어버리고 모든 개념을 순수하게 범주적인 용어, 즉 객체와 화살표의 관점으로 표현하는 것이다.

이상적으로는, Haskell 타입이 집합이고 Haskell 함수가 집합 간의 수학 함수라고 간단히 말할 수 있을 것이다. 여기에는 딱 하나의 작은 문제가 발생한다: 수학 함수는 어떠한 코드도 실행하지 않는다 — 그저 답을 알고 있을 뿐이다. 그러나 Haskell 함수는 답을 계산해야 한다. 답을 얻는 데 유한한 수의 단계가 필요하다면 — 그 숫자가 얼마나 크든 — 문제가 되지 않는다. 그러나 일부 계산에는 재귀가 포함되며, 이러한 계산은 절대 종료되지 않을 수 있다. 종료되는 함수와 종료되지 않는 함수를 구별하는 것은 불가능하기 때문에, Haskell에서 종료되지 않는 함수를 단순히 금지할 수는 없다 (유명한 정지 문제). 그래서 컴퓨터 과학자들은 모든 타입을 하나의 특별한 값, 바닥이라고 불리며 | 또는 유니코드 ⊥로 표시되는 값으로 확장하는 빛나는 아이디어, 또는 관점에 따라, 주요한 해킹을 고안해냈다. 이 "값"은 종료되지 않는 계산에 해당한다. 

따라서 다음과 같이 선언된 함수:
```haskell
f :: Bool -> Bool
```
은 True, False, 또는 _|_를 반환할 수 있으며, 후자는 그것이 결코 종료되지 않을 것임을 의미한다.

흥미롭게도, 타입 시스템의 일부로 바닥 값을 받아들이면, 모든 런타임 오류를 바닥 값으로 취급하는 것이 편리하며, 심지어 함수가 명시적으로 바닥 값을 반환하도록 할 수도 있다. 이런 경우, 주로 'undefined' 표현식을 사용하는데, 예를 들면 다음과 같다:
```haskell
f :: Bool -> Bool
f x = undefined
```
이 정의는 타입 검사를 통과한다. 왜냐하면 'undefined'는 바닥 값으로 평가되고, 바닥 값은 Bool을 포함한 모든 타입의 멤버이기 때문이다. 심지어 다음과 같이 작성할 수도 있다:
```haskell
f :: Bool -> Bool
f = undefined
```
(x 없이) 이는 바닥 값도 타입 Bool->Bool의 멤버이기 때문이다.

바닥 값을 반환할 수 있는 함수를 부분 함수라고 부르며, 이는 모든 가능한 인자에 대해 유효한 결과를 반환하는 전체 함수와 대조된다. 바닥 값 때문에 Haskell 타입과 함수의 범주를 Set이 아닌 Hask로 부르게 되었다. 이론적 관점에서, 이것은 끝없는 복잡함의 시작점이 되지만, 이 시점에서 나는 이 논리적 추론을 여기서 자를 것이다. 실용적 관점에서는, 비종료 함수와 바닥 값을 무시하고 Hask를 진정한 Set으로 취급해도 괜찮다.

# 왜 수학 모델이 필요한가?
프로그래머로서 당신은, 당신이 사용하는 프로그래밍 언어의 문법과 구문을 매우 잘 알고 있다. 이러한 것들은 보통 언어 사양의 시작 부분에서 공식적인 표기법으로 설명된다. 하지만, 언어의 의미 또는 의미론을 설명하는 것은 훨씬 더 어렵고, 거의 형식적이지 않으며, 거의 완전하지 않다는 것이 문제다. 그래서 언어 사양 기여자들 사이의 끊임없는 토론과 언어 표준의 세부 사항을 해석하는 책들이 많이 생겨났다.
언어의 의미를 설명하기 위한 형식적인 도구들이 있지만, 그 복잡성 때문에 대부분 실제 프로그래밍 언어들이 아닌 단순화된 학술적 언어에서 사용된다. 

그 중 하나인 연산 의미론(operational semantics)은 프로그램 실행의 메커니즘을 설명하는 도구이다. 이것은 형식화된 이상적인 인터프리터를 정의한다. C++ 같은 실제 업계 언어의 의미는 주로 "추상 기계(abstract machine)"라는 용어를 통한 비공식적인 연산 추론으로 설명된다.

문제는 프로그램에 대해 연산 의미론을 사용해 증명하는 것이 매우 어렵다는 것이다. 프로그램의 속성을 드러낼려면 사실상 이상적인 인터프리터를 통해 "실행"해야만 한다. 

프로그래머가 정확성에 대한 형식적인 증명을 절대 수행하지 않더라도 그것은 중요하지 않다. 우리는 항상 우리가 올바른 프로그램을 작성한다고 "생각"한다. 아무도 키보드 앞에 앉아 "아, 몇 줄의 코드를 입력해보고 무슨 일이 일어나는지 보자"라고 생각하지 않는다. 우리는 우리가 작성하는 코드가 원하는 결과를 생성할 특정 작업을 수행할 것이라고 생각한다. 그것이 원하는 대로 동작하지 않을 때 우리는 보통 매우 놀란다. 이은 우리가 작성하는 프로그램에 대해 추론하고 있음을 의미하며, 우리는 보통 우리 머릿속의 인터프리터를 실행하면서 그런식으로 행동한다. 모든 변수를 추적하기는 정말 어렵다. 컴퓨터는 프로그램을 실행하는 데 능숙하지만 인간은 그렇지 않다! 만약 그랬다면 우리는 컴퓨터가 필요 없을 것이다.

하지만 표시론적 의미론(denotational semantics)이라고 불리는 대안이 있다. 그것은 수학에 기반하며, 모든 프로그래밍 구조가 그것의 수학적 해석을 받는다. 이를 통해 프로그램의 속성을 증명하고 싶다면, 단순히 수학적 정리를 증명하면 된다. 정리 증명이 어렵다고 생각할 수 있지만, 사실 우리 인간은 수천 년 동안 수학적 방법을 구축해왔으므로, 활용할 수 있는 풍부한 지식이 축적되어 있다. 또한, 전문 수학자들이 증명하는 정리들과 비교할 때, 프로그래밍에서 생기는 문제들은 대체로 꽤 간단하거나 사소한 경우가 많다.

하스켈에서 팩토리얼 함수의 정의를 고려해 보면, 하스켈은 표현 의미론에 매우 적합한 언어이다:
```haskell
fact n = product [1..n]
```
표현식 [1..n]은 1부터 n까지의 정수 리스트이다. 함수 product는 리스트의 모든 요소를 곱한다. 이것은 수학 교과서에서 가져온 팩토리얼의 정의와 같다. 이것을 C 언어와 비교해 보면:
```c
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```
더 말할 필요가 있겠는가?

팩토리얼 함수는 명백한 수학적 의미를 가진다. 눈치 빠른 독자라면 이렇게 물을 수 있다: 키보드에서 문자를 읽거나 네트워크를 통해 패킷을 보내는 것에 대한 수학적 모델은 무엇인가? 상당한 시간 동안 이것은 복잡한 설명으로 이어지는 어색한 질문이었다. 유용한 프로그램을 작성하는 데 필수적인 많은 중요한 작업들이 표시론적 의미론에 잘 맞지 않는 것처럼 보였고, 연산 의미론으로 쉽게 해결할 수 있었다. 돌파구는 범주론에서 왔다. Eugenio Moggi는 계산 효과를 모나드에 매핑할 수 있다는 것을 발견했다. 이것은 표시론적 의미론에 새로운 생명을 부여하고 순수 함수형 프로그램을 더 사용하기 쉽게 만들 뿐만 아니라 전통적인 프로그래밍에 대한 새로운 시각을 제공하는 중요한 발견이 되었다. 모나드에 대해서는, 범주론적 도구를 더 개발할 때 이야기할 것이다.

프로그래밍에서 수학적 모델을 가짐으로써 얻는 핵심적인 이점 중 하나는 소프트웨어의 정확성에 대한 형식적 증명을 할 수 있다는 것이다. 이것은 팔리는 소프트웨어를 작성할 때는 그리 중요해 보이지 않을 수 있지만, 실패의 대가가 엄청나거나 인간의 생명이 달린 프로그래밍 영역에서는 매우 중요하다. 하지만 헬스 케어을 위한 웹 애플리케이션을 작성할 때조차도, 하스켈 표준 라이브러리의 함수와 알고리즘이 정확성 증명과 함께 제공된다는 사실을 인정할 수 있을 것이다.

# 순수 함수와 비순수 함수
C++이나 다른 명령형 언어에서 우리가 함수라고 부르는 것들은 수학자들이 함수라고 부르는 것과 동일하지 않다. 수학적 함수는 단지 값에서 값으로의 매핑이다.

프로그래밍 언어에서 수학적 함수를 구현할 수 있다: 이러한 함수는 입력값을 받아 출력값을 계산한다. 숫자의 제곱을 생성하는 함수는 아마도 입력값을 그 자신과 곱할 것이다. 이 함수는 호출될 때마다 그렇게 하며, 같은 입력에 대해 항상 동일한 출력을 생성할 것이 보장된다. 숫자의 제곱은 달의 상태에 따라 변하지 않는다.

또한, 숫자의 제곱을 계산하는 것은 당신의 개에게 맛있는 간식을 제공하는 부수 효과를 가져서는 안 된다. 그렇게 하는 "함수"는 수학적 함수로 쉽게 모델링될 수 없다.

프로그래밍 언어에서 동일한 입력이 주어졌을 때 항상 같은 결과를 생성하고 부수 효과가 없는 함수를 순수 함수라고 한다. Haskell과 같은 순수 함수형 언어에서는 모든 함수가 순수하다. 그 때문에, 이러한 언어들에 대해 표시론적 의미론을 제공하고 범주론을 사용해 모델링하는 것이 더 쉽다. 다른 언어들에서는, 순수한 부분 집합으로 자신을 항상 제한하거나 부수 효과에 대해 별도로 추론할 수 있다. 나중에 우리는 모나드가 오직 순수 함수만을 사용하여 어떻게 모든 종류의 효과를 모델링할 수 있게 해주는지 볼 것이다. 그럼으로인해 우리는 수학적 함수에 자신을 제한함으로써 정말로 잃는 것이 없다.

# 타입의 예시
타입이 집합이라는 것을 깨달으면, 상당히 이색적인 타입들에 대해 생각할 수 있다. 예를 들어, 빈 집합(공집합)에 해당하는 타입은 무엇일까? C++의 void는 아니다. 이 타입은 Haskell에서는 Void라고 불린다. 이것은 어떤 값도 포함하지 않는 타입이다. Void를 인자로 받는 함수를 정의할 수는 있지만, 실제로 호출할 수는 없다. 호출하기 위해서는 Void 타입의 값을 제공해야 하는데, 그런 값은 존재하지 않기 때문이다. 이 함수의 반환값에는 어떤 제한도 없다. 어떤 타입도 반환할 수 있지만(실제로 호출될 수 없으므로 반환할 일은 없지만), 다시 말해 이것은 반환 타입에 다형성을 가진 함수이다. Haskell 사용자들은 이를 absurd라고 부른다:
```haskell
absurd :: Void -> a
```
(여기서 a는 어떤 타입이든 될 수 있는 타입 변수임을 기억하라) 이 이름은 우연히 생긴 것이 아니다. 타입과 함수에 대한 더 깊은 해석이 논리학적으로 Curry-Howard 동형성을 통해 제시되는데, Void 타입은 거짓을 나타내고, absurd 함수의 타입은 거짓에서는 무엇이든 따른다는 명제에 해당한다, 라틴 격언 "ex falso sequitur quodlibet"처럼.

다음은 한원소집합(singleton set)에 해당하는 타입이다. 이것은 오직 하나의 가능한 값을 가진 타입이다. 이 값은 그냥 "존재한다." 처음에는 그렇게 인식하지 못할 수도 있지만, 그것이 C++의 void이다. 이 타입에서, 그리고 이 타입으로의 함수에 대해 생각해 보라. void에서 온 함수는 항상 호출될 수 있다. 순수 함수라면 항상 동일한 결과를 반환한다. 다음은 그러한 함수의 예이다:
```c
int f44() { return 44; }
```
이 함수가 "아무것도" 받지 않는다고 생각할 수 있지만, 방금 본 것처럼 "아무것도" 받지 않는 함수는 호출될 수 없다. 왜냐하면 "아무것도"를 나타내는 값이 없기 때문이다. 그렇다면 이 함수는 무엇을 받는가? 개념적으로, 이것은 오직 한 인스턴스만 존재하는 더미 값으로, 우리가 명시적으로 언급하지 않아도 된다. 그러나 Haskell에서는 이 값에 대한 심볼이 있다: 빈 괄호 쌍, (). 그래서 재미있게도(또는 우연인가?), C++과 Haskell에서 void 함수의 호출이 동일하게 보인다. 또한, Haskell의 간결함에 대한 사랑 때문에, 동일한 심볼 ()이 타입, 생성자, 그리고 싱글톤 집합에 해당하는 유일한 값에 사용된다. 그래서 Haskell에서 이 함수는 다음과 같다:
```haskell
f44 :: () -> Integer
f44 () = 44
```
첫 번째 줄은 f44가 타입 (), ("유닛"으로 불린다)을 Integer 타입으로 받는다고 선언한다. 두 번째 줄은 f44를 정의함으로써 유닛의 유일한 생성자, 즉 (),을 패턴 매칭하여 숫자 44를 생성한다. 이 함수를 호출하려면 유닛값 ()을 제공한다:
```haskell
f44 ()
```
유닛의 함수는 타깃 타입에서 단일 요소를 선택하는 것과 동등하다. 사실, f44를 숫자 44의 다른 표현으로 생각할 수 있다. 이것은 집합의 요소를 명시적으로 언급하는 대신 함수에 대해 이야기함으로써 대체할 수 있는 방법의 예이다. 어떤 타입 A로부터 유닛으로의 함수는 그 집합 A의 요소와 일대일 대응 관계에 있다.

void 반환 타입을 가진 함수, 또는 Haskell에서의 unit 반환 타입을 가진 함수는 어떨까? C++에서 이러한 함수들은 부수 효과를 위해 사용되지만, 우리는 이것들이 수학적 의미에서의 진짜 함수가 아니라는 것을 알고 있다. unit을 반환하는 순수 함수는 아무것도 하지 않는다: 이 함수는 그 인자를 버린다.

수학적으로, 집합 𝐴에서 싱글톤 집합으로의 함수는 𝐴의 모든 원소를 그 싱글톤 집합의 유일한 원소로 매핑한다. 정확히 모든 𝐴에 대해 그러한 함수가 하나 있다. 여기 Integer에 대한 그 함수 예시이다:
```haskell
fInt :: Integer -> ()
fInt x = ()
```
이 함수에 어떤 정수를 주면, 이 함수는 당신에게 unit을 반환한다. Haskell은 간결함을 위해 버려지는 인자에 대해 와일드카드 패턴(밑줄)을 사용할 수 있게 해준다. 이를 통해 인자 이름을 지을 필요가 없다. 그래서 위 코드는 다음과 같이 다시 쓸 수 있다:
```haskell
fInt :: Integer -> ()
fInt _ = ()
```
이 함수의 구현은 전달된 값 의존하지 않을 뿐만 아니라, 인자의 타입에도 의존하지 않는다.

모든 타입에 대해 동일한 공식으로 구현될 수 있는 함수들을 매개변수적 다형성을 가진 함수라고 한다. 구체적인 타입 대신 타입 매개변수를 사용하여 한 방정식으로 이러한 함수의 전가족을 구현할 수 있다.
어떤 타입에서 unit 타입으로의 다형성 함수를 무엇이라고 부를까? 우리는 이를 물론 unit이라고 부를 것이다:
```haskell
unit :: a -> ()
unit _ = ()
```
C++에서는 이 함수를 다음과 같이 작성할 것이다:
```cpp
template<class T>
void unit(T) {}
```
타입의 분류에서 다음은 두 원소 집합이다. C++에서는 이것을 bool이라고 부르며, 예상대로 Haskell에서는 Bool이다. 차이점은 C++에서 bool은 내장 타입인 반면, Haskell에서는 다음과 같이 정의될 수 있다:
```haskell
data Bool = True | False
```
(이 정의는 Bool이 True 또는 False라고 읽는다) 원칙적으로, C++에서도 열거형으로 Boolean 타입을 정의할 수 있어야 하지만, C++ enum은 사실상 정수다. C++11의 "enum class"가 대신 사용될 수 있었지만, 그러면 그 값을 클래스 이름, 즉 bool::true와 bool::false로 지정해야 하며, 사용하는 모든 파일에 적절한 헤더를 포함해야 한다.

Bool로부터의 순수 함수는 대상 타입에서 True에 해당하는 값과 False에 해당하는 또 다른 값을 선택한다.
Bool로의 함수는 predicate라고 불린다. 예를 들어, Haskell 라이브러리 Data.Char은 isAlpha나 isDigit과 같은 predicate로 가득 차 있다. C++에는 isalpha와 isdigit을 포함하는 비슷한 라이브러리가 있지만, 이들은 Boolean 대신 int를 반환한다. 실제 predicate는 std::ctype에 정의되어 있고 ctype::is(alpha, c), ctype::is(digit, c) 등의 형태를 가진다.